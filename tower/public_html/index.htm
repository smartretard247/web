<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Jesse Young Final Project</title>
<style>
  body {
    background-color: #EEEEEE;
  }
</style>

<script type="x-shader/x-vertex" id="vshaderBASIC">
  attribute vec3 a_coords;
  uniform mat4 modelviewProjection;
  uniform bool lit;
  uniform vec3 normal;
  uniform mat3 normalMatrix;
  uniform vec4 color;
  varying vec4 v_color;
  void main() {
    vec4 coords = vec4(a_coords,1.0);
    gl_Position = modelviewProjection * coords;
    if (lit) {
      vec3 N = normalize(normalMatrix*normal);  // Transformed unit normal
      float dotProduct = abs(N.z);  // cosine of angle of incidence of light with surface
      v_color = vec4( dotProduct*color.rgb, color.a );
    } else {
      v_color = color;
    }
  }
</script>
<script type="x-shader/x-fragment" id="fshaderBASIC">
  #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
  #else
    precision mediump float;
  #endif
  varying vec4 v_color;
  void main() {
    gl_FragColor = v_color;
  }
</script>

<!-- shader program for textures -->
<script type="x-shader/x-vertex" id="vshaderTEX">
  uniform mat4 modelviewProjection;
  attribute vec2 a_coords;
  attribute vec2 a_texCoords;
  varying vec2 v_texCoords;
  void main() {
    v_texCoords = a_texCoords;
    vec4 coords = vec4(a_coords, 0.0, 1.0);
    gl_Position = modelviewProjection * coords;
  }
</script>
<script type="x-shader/x-fragment" id="fshaderTEX">
  #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
  #else
    precision mediump float;
  #endif
  uniform sampler2D u_texture; // A sampler variable to represent the texture.
  varying vec2 v_texCoords;    // The texture coordinates for this pixel.
  void main() {
    vec4 color = texture2D( u_texture, v_texCoords ); // Sample the texture.
    if(color.a < 0.5) discard; // apply transparency
    gl_FragColor = color; // Just use the color from the texture as the pixel color.
  }
</script>

<!-- shader program for rendering with specular lighting -->
<script type="x-shader/x-vertex" id="vshaderSPEC">
  attribute vec3 a_coords;
  attribute vec3 a_normal;
  uniform bool lit;
  uniform mat4 modelview;
  uniform mat4 projection;
  uniform mat3 normalMatrix;
  uniform vec4 lightPosition;
  uniform vec4 diffuseColor;
  uniform vec3 specularColor;
  uniform float specularExponent;
  varying vec4 v_color;
  void main() {
    vec4 coords = vec4(a_coords,1.0);
    vec4 eyeCoords = modelview * coords;
    gl_Position = projection * eyeCoords;
    if (lit) {
      vec3 N, L, R, V;  // vectors for lighting equation
      N = normalize( normalMatrix*a_normal );
      if ( lightPosition.w == 0.0 ) {
        L = normalize( lightPosition.xyz );
      } else {
        L = normalize( lightPosition.xyz/lightPosition.w - eyeCoords.xyz );
      }
      R = -reflect(L,N);
      V = normalize( -eyeCoords.xyz);  // (Assumes a perspective projection.)
      if ( dot(L,N) <= 0.0 ) {
        v_color = vec4(0,0,0,1);
      } else {
        vec3 color = 0.8*dot(L,N) * diffuseColor.rgb;  // 0.8 is diffuse intensity of light
        if (dot(R,V) > 0.0) {
          color += 0.4*pow(dot(R,V),specularExponent) * specularColor; // 0.4 is specular intensity of light
        }
        v_color = vec4(color, diffuseColor.a);
      }
    } else {
      v_color = diffuseColor; // use diffuse as a plain color, no lighting
    }
  }
</script>
<script type="x-shader/x-fragment" id="fshaderSPEC">
  #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
  #else
    precision mediump float;
  #endif
  varying vec4 v_color;
  void main() {
    gl_FragColor = v_color;
  }
</script>

<script src="webgl/trackball-rotator.js"></script>
<script src="webgl/gl-matrix-min.js"></script>
<script src="webgl/basic-object-models-IFS.js"></script>
<script src="blocks.js"></script>

<script>
"use strict";
var gl;   // The webgl context.
var frameNumber = 0;

var doorRotatedDeg = 0; // track door open/close degrees
var doorOpening = true;

var windowOpening = true;
var windowRotatedDeg = 0; // track windows open/close degrees

var ladderRPosDirection = true;
var ladderRotatedDeg = 0;
var ladderRotating = true;
var ladderPosDirection = true;
var ladderExtendedLen = 0;
var ladderExtending = false;

var explodedView = false;

var mainShader; // regular shader, basic colors and a light source
var texShader; // for rendering objects with textures
var specShader; // for specular lighting

// texture constants
var TEX_DOOR = 0;
var TEX_WINDOW = 1;
var TEX_WINDOW2 = 2;
var TEX_DOG = 3;
var textureObject = []; // to hold the textures

var projection = mat4.create();    // projection matrix
var modelviewProj = mat4.create(); // combined transformation matrix
var normalMatrix = mat3.create(); // matrix, derived from modelview matrix, for transforming normal vectors
var rotator;  // A SimpleRotator object that lets the user rotate the view by mouse.
var viewZ = -80; // used for moving the viewing location up and down the z-axis, based on mouse scroll
var transY = 0;  // used to navigate the y-axis for better zoomed viewing

var lightPositions = [  // values for light position, selected by popup menu
  [0,0,0,1], [0,0,1,0], [0,1,0,0], [0,0,-5,1], [2,3,5,0]
];

// define available colors
var RED = [1,0,0,1];
var GREEN = [0,1,0,1];
var BLUE = [0,0,1,1];
var BLACK = [0,0,0,1];
var WHITE = [1,1,1,1];
var YELLOW = [1,1,0,1];
var CYAN = [0,1,1,1];
var ORANGE = [1,0.647059,0,1];
var GRAY = [0.745098,0.745098,0.745098,1];
var BROWN = [0.647059,0.164706,0.164706,1];
var MAROON = [0.690196,0.188235,0.376471,1];
var LIME = [0.564706,0.933333,0.564706,1];

// contains all 'types' of building blocks
var objects = [  // Objects for display
  uvCylinder(3/8/2,3/16), // for pegs
  box(block[BASE].w,block[BASE].h,block[BASE].l), // the base pad (8x8)
  box(block[PAD_FULL].w,block[PAD_FULL].h,block[PAD_FULL].l), // a full pad (8x2)
  box(block[PAD_TRP].w,block[PAD_TRP].h,block[PAD_TRP].l), // a smaller pad (6x2)
  box(block[PAD_DBL].w,block[PAD_DBL].h,block[PAD_DBL].l), // an even smaller pad (4x2)
  box(block[PAD_QTR].w,block[PAD_QTR].h,block[PAD_QTR].l), // a quarter pad (2x2)
  box(block[BLOCK_FULL].w,block[BLOCK_FULL].h,block[BLOCK_FULL].l), // a long regular block
  box(block[BLOCK_TRP].w,block[BLOCK_TRP].h,block[BLOCK_TRP].l), // a 6x2 regular block
  box(block[BLOCK_DBL].w,block[BLOCK_DBL].h,block[BLOCK_DBL].l), // a 4x2 regular block
  box(block[BLOCK_QTR].w,block[BLOCK_QTR].h,block[BLOCK_QTR].l), // a 2x2 regular block
  box(block[BLOCK_MIN].w,block[BLOCK_MIN].h,block[BLOCK_MIN].l), // a 1x2 doubl height block
  box(block[BLOCK_SIN].w,block[BLOCK_SIN].h,block[BLOCK_SIN].l), // a 1x2 doubl height block
  uvCylinder(PEG/2,BLOCK_HEIGHT), // for a singular circle block
  box(block[BLOCK_E].w,block[BLOCK_E].h,block[BLOCK_E].l), // an oddly shaped 'e' block
  box(block[DOOR].w,block[DOOR].h,block[DOOR].l),
  box(block[WINDOW].w,block[WINDOW].h,block[WINDOW].l),
  uvCylinder(PEG*2,PEG*2,false,false)
];

// fill the block objects with game objects
for(var i = 0; i < block.length; i++) {
  block[i].obj = objects[block[i].index];
}

/*----------------------- Current transform and transform stack --------------*/
function MatrixStack() {
  this.stack = [];
  this.popMatrix();
}

// Pops the top of the stack restoring the previously saved matrix
MatrixStack.prototype.popMatrix = function() {
  this.stack.pop();
  if (this.stack.length < 1) {
    this.stack[0] = mat4.create();
  }
};

// Pushes a copy of the current matrix on the stack
MatrixStack.prototype.pushMatrix = function() {
  this.stack.push(this.getCurrentMatrix());
};

// Gets a copy of the current matrix (top of the stack)
MatrixStack.prototype.getCurrentMatrix = function() {
  return this.stack[this.stack.length - 1].slice();
};

// Lets us set the current matrix
MatrixStack.prototype.setCurrentMatrix = function(m) {
  return this.stack[this.stack.length - 1] = m;
};

MatrixStack.prototype.translate = function(x,y,z) {
  if (z === undefined) {
    z = 0;
  }
  var m = this.getCurrentMatrix();
  this.setCurrentMatrix(mat4.translate(m, m, [x,y,z]));
};

MatrixStack.prototype.scale = function(x,y,z) {
  if (z === undefined) {
    z = 1;
  }
  if (y === undefined) { // then do uniform scale
    y = x;
    z = x;
  }
  var m = this.getCurrentMatrix();
  this.setCurrentMatrix(mat4.scale(m, m, [x,y,z]));
};

MatrixStack.prototype.rotateX = function(degrees) {
  var rad = Math.PI * degrees / 180.0; // Convert to radians
  var m = this.getCurrentMatrix();
  this.setCurrentMatrix(mat4.rotateX(m, m, rad));
};

MatrixStack.prototype.rotateY = function(degrees) {
  var rad = Math.PI * degrees / 180.0; // Convert to radians
  var m = this.getCurrentMatrix();
  this.setCurrentMatrix(mat4.rotateY(m, m, rad));
};

MatrixStack.prototype.rotateZ = function(degrees) {
  var rad = Math.PI * degrees / 180.0; // Convert to radians
  var m = this.getCurrentMatrix();
  this.setCurrentMatrix(mat4.rotateZ(m, m, rad));
};

MatrixStack.prototype.rotate = function(degrees, v3) {
  var rad = Math.PI * degrees / 180.0; // Convert to radians
  var m = this.getCurrentMatrix();
  this.setCurrentMatrix(mat4.rotate(m, m, rad, v3));
};

MatrixStack.prototype.combineAndSend = function(mvProjection) {
  mat4.multiply( modelviewProj, projection, matrixStack.getCurrentMatrix() );
  gl.uniformMatrix4fv(mvProjection, false, modelviewProj );
};

var matrixStack = new MatrixStack();

// add user ability to move up and down the z-axis, based on mouse scrolling
function MouseWheelHandler(e) {
	var e = window.event || e; // old IE support
	var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));
  viewZ += delta;
  draw();
	return false;
}

// enable/disable mouse scrolling
function toggleScroll() {
  if(document.getElementById("scroll").checked === true) {
    document.addEventListener("mousewheel", MouseWheelHandler, false); // IE9, Chrome, Safari, Opera
    document.addEventListener("DOMMouseScroll", MouseWheelHandler, false); // Firefox
  } else {
    document.removeEventListener("mousewheel", MouseWheelHandler, false); // IE9, Chrome, Safari, Opera
    document.removeEventListener("DOMMouseScroll", MouseWheelHandler, false); // Firefox
  }
}

// add data to object model, for a box of given dimensions
function box(width, height, length) {
   var x = (width || 1)/2;
   var y = (height || 1)/2;
   var z = (length || 1)/2;
   var coords = [];
   var normals = [];
   var texCoords = [];
   var indices = [];
   function face(xyz, nrm) {
      var start = coords.length/3;
      var i;
      for (i = 0; i < 12; i++) {
         coords.push(xyz[i]);
      }
      for (i = 0; i < 4; i++) {
         normals.push(nrm[0],nrm[1],nrm[2]);
      }
      texCoords.push(0,0,1,0,1,1,0,1);
      indices.push(start,start+1,start+2,start,start+2,start+3);
   }
   face( [-x,-y,z, x,-y,z, x,y,z, -x,y,z], [0,0,1] ); // front
   face( [-x,-y,-z, -x,y,-z, x,y,-z, x,-y,-z], [0,0,-1] ); // back
   face( [-x,y,-z, -x,y,z, x,y,z, x,y,-z], [0,1,0] ); // top
   face( [-x,-y,-z, x,-y,-z, x,-y,z, -x,-y,z], [0,-1,0] ); // bottom
   face( [x,-y,-z, x,y,-z, x,y,z, x,-y,z], [1,0,0] ); // right
   face( [-x,-y,-z, -x,-y,z, -x,y,z, -x,y,-z], [-1,0,0] ); // left
   return {
      vertexPositions: new Float32Array(coords),
      vertexNormals: new Float32Array(normals),
      vertexTextureCoords: new Float32Array(texCoords),
      indices: new Uint16Array(indices)
   };
}

/* Draws a WebGL primitive.  The first parameter must be one of the constants
 * that specifiy primitives:  gl.POINTS, gl.LINES, gl.LINE_LOOP, gl.LINE_STRIP,
 * gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN.  The second parameter must
 * be an array of 4 numbers in the range 0.0 to 1.0, giving the RGBA color of
 * the color of the primitive.  The third parameter must be an array of numbers.
 * The length of the array must be amultiple of 3.  Each triple of numbers provides
 * xyz-coords for one vertex for the primitive.  This assumes that u_color is the
 * location of a color uniform in the shader program, a_coords_loc is the location of
 * the coords attribute, and a_coords_buffer is a VBO for the coords attribute.
 */
function drawPrimitive( primitiveType, color, vertices, drawMethod ) {
  drawMethod = (drawMethod === undefined) ? gl.STREAM_DRAW : gl.STATIC_DRAW;
  gl.enableVertexAttribArray(mainShader.a_coords_loc);
  gl.bindBuffer(gl.ARRAY_BUFFER,mainShader.a_coords_buffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), drawMethod);
  gl.uniform4fv(mainShader.u_color, color);
  gl.vertexAttribPointer(mainShader.a_coords_loc, 3, gl.FLOAT, false, 0, 0);
  gl.drawArrays(primitiveType, 0, vertices.length/3);
}

/* Draw coordinate axes as thick colored lines that extend through the cube.
 * The lines are drawn with lighting disabled. */
function drawAxes() {
  gl.useProgram(mainShader.prog);
  gl.uniform1i( mainShader.u_lit, 0 );  // Turn off lighting
  gl.lineWidth(4);
  drawPrimitive( gl.LINES, [1,0,0,1], [ -2,0,0, 2,0,0] );
  drawPrimitive( gl.LINES, [0,1,0,1], [ 0,-2,0, 0,2,0] );
  drawPrimitive( gl.LINES, [0,0,1,1], [ 0,0,-2, 0,0,2] );
  gl.lineWidth(1);
}

function drawTexturedPrimitive( primitiveType, texCoords, vertices, drawMethod ) {
  drawMethod = (drawMethod === undefined) ? gl.STREAM_DRAW : gl.STATIC_DRAW;
  
  gl.bindBuffer(gl.ARRAY_BUFFER, texShader.a_coords_buffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( vertices ), drawMethod);
  gl.vertexAttribPointer(texShader.a_coords_loc, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(texShader.a_coords_loc);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, texShader.a_texCoords_buffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( texCoords ), drawMethod);
  gl.vertexAttribPointer(texShader.a_texCoords_loc, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(texShader.a_texCoords_loc);
  
  gl.drawArrays(primitiveType, 0, vertices.length/2);
}

function drawTexturedRectangle(width, height, texNum, stretch) {
  stretch = stretch || false;
  
  gl.useProgram(texShader.prog); // ensure we are using texture shader
  gl.uniform1i(texShader.u_texture_loc, texNum);
  
  matrixStack.pushMatrix();
  var texWidth = width;
  var texHeight = height;
  
  if(stretch === true) {
    texWidth = 1;
    texHeight = 1;
  }
  
  matrixStack.combineAndSend(texShader.u_modelviewProj);
  drawTexturedPrimitive( gl.TRIANGLE_FAN, [ 0,0, texWidth,0, texWidth,texHeight, 0,texHeight ],
          [ -width/2,-height/2, width/2,-height/2, width/2,height/2, -width/2,height/2 ]);
  matrixStack.popMatrix();
}

/*
 * Draws a 3D box with given dimensions and texture, centered at 0,0,0
 */
function drawTexturedBox(width, height, length, texNum, stretch, noTopBottom, noSides) {
  stretch = stretch || false;
  noTopBottom = noTopBottom || false;
  noSides = noSides || false;
  
  gl.useProgram(texShader.prog); // ensure we are using texture shader
  matrixStack.pushMatrix();
  
  // draw front and back sides first
  for(var i = 0; i < 2; i++) {
    matrixStack.rotateY(i*180);
    matrixStack.pushMatrix();
    matrixStack.translate(0, 0, length/2); //gl.glTranslated(0, 0, 0.5);
    drawTexturedRectangle(width, height, texNum, stretch); // draw a unit rectangle, at current scale
    matrixStack.popMatrix();
  }
  
  if(!noSides) {
    // draw two sides
    matrixStack.rotateY(90);
    for(var i = 0; i < 2; i++) {
      matrixStack.rotateY(i*180);
      matrixStack.pushMatrix();
      matrixStack.translate(0, 0, width/2); //gl.glTranslated(0, 0, 0.5);
      drawTexturedRectangle(length, height, texNum, stretch); // draw a unit rectangle, at current scale
      matrixStack.popMatrix();
    }
  }
  
  if(!noTopBottom) {
    // draw top and bottom
    matrixStack.rotateX(90);
    for(var i = 0; i < 2; i++) {
      matrixStack.rotateY(i*180);
      matrixStack.pushMatrix();
      matrixStack.translate(0, 0, height/2); //gl.glTranslated(0, 0, 0.5);
      drawTexturedRectangle(length, width, texNum, stretch); // draw a unit rectangle, at current scale
      matrixStack.popMatrix();
    }
  }
  
  matrixStack.popMatrix();
  matrixStack.combineAndSend(texShader.u_modelviewProj);
}

/* 
  * Draws a rectangle with the given color based on the given scales, centered at (0,0,0) and
  * facing in the +z direction.
 */
function drawRectangle(width, height, color) {
  matrixStack.pushMatrix();
  matrixStack.scale(width, height, 1);
  gl.uniform3f( mainShader.u_normal, 0, 0, 1 ); // send normal vector to shader program
  matrixStack.combineAndSend(mainShader.u_modelviewProj);
  drawPrimitive( gl.TRIANGLE_FAN, color, [ -0.5,-0.5,0, 0.5,-0.5,0, 0.5,0.5,0, -0.5,0.5,0 ]);
  matrixStack.popMatrix();
}

/*
 * Draws a 3D box with given dimensions and color, centered at 0,0,0
 */
function drawBox(width, height, length, color) {
  matrixStack.pushMatrix();
  matrixStack.scale(width, height, length); //scale whole object to size
  
  for(var i = 0; i < 3; i++) {
    matrixStack.rotate(120, [0.5,0.5,0.5]); //gl.glRotated(120, 0.5, 0.5, 0.5);
    for(var j = 0; j < 2; j++) {
      matrixStack.pushMatrix();
      matrixStack.rotateX(j*90); //gl.glRotated(j*90, 1, 0, 0);
      matrixStack.translate(0, 0, 0.5); //gl.glTranslated(0, 0, 0.5);
      drawRectangle(1, 1, color); // draw a unit rectangle, at current scale
      matrixStack.popMatrix();
    }
  }
  matrixStack.popMatrix();
  matrixStack.combineAndSend(mainShader.u_modelviewProj);
}

// draw an object from the list of preloaded vertices
function drawSpecularObject(object, diffuseColor) {
  var d = diffuseColor;
  gl.useProgram(specShader.prog);
  mat3.normalFromMat4(normalMatrix, matrixStack.getCurrentMatrix());
  gl.uniformMatrix3fv(specShader.u_normalMatrix_loc, false, normalMatrix);
  gl.uniformMatrix4fv(specShader.u_modelview_loc, false, matrixStack.getCurrentMatrix() );
  gl.uniformMatrix4fv(specShader.u_projection_loc, false, projection );
  gl.uniform4f(specShader.u_diffuseColor_loc, d[0], d[1], d[2], d[3] );
  installModel(object);
  gl.drawElements(gl.TRIANGLES, object.indices.length, gl.UNSIGNED_SHORT, 0);
}

// draw pegs on given block, should only be called by drawBlock()
function drawPegs(onBlock, color) {
  var offsetX = -onBlock.w/2+PEG/2;  // adjust for peg width
  var offsetY = onBlock.h/2+3/32; // adjust for block and peg height
  var offsetZ = -onBlock.l/2+PEG/2;  // adjust for peg length
  matrixStack.pushMatrix();
  matrixStack.translate(offsetX,offsetY,offsetZ); // offset starting peg location
  matrixStack.rotateX(90);
  
  var colCount = onBlock.w/(5/8); // how many columns to draw
  var rowCount = onBlock.l/(5/8); // how many rows to draw
  var spacing = 3/8+1/4; // peg width plus 1/4 space
  
  for(var j = 0; j < rowCount; j++) {
    matrixStack.pushMatrix();
    for(var i = 0; i < colCount; i++) { // FIX
      drawSpecularObject(objects[0], color); // pegs on top of block
      matrixStack.translate(spacing,0,0); // draw along x-axis
    }
    matrixStack.popMatrix();
    matrixStack.translate(0,spacing,0); // move to next row
  }
  
  matrixStack.popMatrix();
}

function move(cols, rows) { // moves the current drawing position based on pegs
  matrixStack.translate(PEG*cols,0,PEG*rows);
}

function elevateBy(height) {
  matrixStack.translate(0,height,0);
}

// draws a special e shaped block out of smaller blocks, again shouldn't call directly
function drawE(color) {
  matrixStack.pushMatrix();
  matrixStack.translate(PEG/2,block[BLOCK_E].h/2,0);
  drawSpecularObject(objects[block[BLOCK_E].index], color);
  elevateBy(BLOCK_HEIGHT_DEF);
  drawSpecularObject(objects[block[BLOCK_SIN].index], color);
  drawPegs(block[BLOCK_SIN], color);
  move(1.5,0);
  drawSpecularObject(objects[block[BLOCK_SIN].index], color);
  drawPegs(block[BLOCK_SIN], color);
  move(-3,0);
  drawSpecularObject(objects[block[BLOCK_SIN].index], color);
  drawPegs(block[BLOCK_SIN], color);
  matrixStack.popMatrix();
}

function buildLadder() {
  var rail = uvCylinder(0.2,block[PAD_TRP].w);
  var rung = uvCylinder(0.1,block[PAD_TRP].h*2);

  matrixStack.pushMatrix();
    matrixStack.translate(-BLOCK_HEIGHT_DEF-PAD_HEIGHT_DEF,0,0);
    for(var i = 0; i < 5; i++) {
      drawSpecularObject(rung, GRAY);
      matrixStack.translate(BLOCK_HEIGHT_DEF,0,0);
    }
  matrixStack.popMatrix();

  matrixStack.translate(block[PAD_TRP].w/2-BLOCK_HEIGHT_DEF*2,0,0);
  matrixStack.pushMatrix();
    matrixStack.rotateY(90);
    matrixStack.translate(PAD_HEIGHT_DEF,0,0);
    drawSpecularObject(rail, GRAY);
  matrixStack.popMatrix();
  matrixStack.pushMatrix();
    matrixStack.rotateY(-90);
    matrixStack.translate(PAD_HEIGHT_DEF,0,0);
    drawSpecularObject(rail, GRAY);
  matrixStack.popMatrix();
}

function drawLadder(color) {
  matrixStack.pushMatrix();
    if(animating[ANIM_LADDER] && !ladderExtending) {
      if(ladderRPosDirection) {
        ladderRotatedDeg -= 1;
      } else {
        ladderRotatedDeg += 1;
      }
      if(ladderRotatedDeg < -75 || ladderRotatedDeg > -1) { // stop animation
        if(ladderRotatedDeg > -1 ) {
          animating[ANIM_LADDER] = false;
          ladderExtending = false;
          ladderRotating = true;
          ladderRPosDirection = true;
        }
        if(ladderRotatedDeg < -75) {
          ladderRotating = false;
          ladderExtending = true;
          ladderRPosDirection = false;
        }
      }
    }
    
    var bottom = uvCylinder(BLOCK_HEIGHT_DEF-0.2,1);
    drawSpecularObject(bottom, color); // bottom portion shouldn't move
    
    matrixStack.rotateY(ladderRotatedDeg);
    matrixStack.rotateZ(20);
    matrixStack.translate(PAD_HEIGHT_DEF,BLOCK_HEIGHT_DEF,0);
    
    buildLadder();
    
    if(animating[ANIM_LADDER] && !ladderRotating) {
      var offset = 0.1;
      if(ladderPosDirection) {
        ladderExtendedLen += offset;
      } else {
        ladderExtendedLen -= offset;
      }
      if(ladderExtendedLen > (block[PAD_TRP].w-PAD_HEIGHT_DEF-offset) || ladderExtendedLen < offset) { // stop animation
        if(ladderExtendedLen > (block[PAD_TRP].w-PAD_HEIGHT_DEF-offset) ) {
          animating[ANIM_LADDER] = false;
          ladderRotating = false;
          ladderExtending = true;
          ladderPosDirection = false;
        }
        if(ladderExtendedLen < 1) {
          ladderRotating = true;
          ladderExtending = false;
          ladderPosDirection = true;
        }
      }
    }
    matrixStack.translate(ladderExtendedLen,0,0);
    buildLadder();
  matrixStack.popMatrix();
}

// create a flower for the botom front
function drawFlower(color) {
  var petal = uvCylinder(PAD_HEIGHT_DEF/1.5,PAD_HEIGHT_DEF);
  
  drawBlock(BLOCK_CIRCLE, color);
  matrixStack.pushMatrix();
    matrixStack.translate(0, BLOCK_HEIGHT_DEF-PAD_HEIGHT_DEF/2, 0);
    matrixStack.rotateX(90);
    for(var i = 0; i < 5; i++) {
      matrixStack.pushMatrix();
      matrixStack.rotateZ(360/5*i);
      matrixStack.translate(0, PAD_HEIGHT_DEF, 0);
      drawSpecularObject(petal, color);
      matrixStack.popMatrix();
    }
  matrixStack.popMatrix();
}

// draw door, with blocks and a texture as the door
function drawDoor(color) {
  matrixStack.pushMatrix();
  matrixStack.translate(0,block[DOOR].h/2,0);
  
  matrixStack.pushMatrix();
    elevateBy(block[BLOCK_MIN].h/2);
    matrixStack.pushMatrix();
      matrixStack.rotateY(90);
      move(0,-1.5);
      drawSpecularObject(objects[block[BLOCK_MIN].index], color);
      move(0,3);
      drawSpecularObject(objects[block[BLOCK_MIN].index], color);
    matrixStack.popMatrix();
  matrixStack.popMatrix();
  
  matrixStack.pushMatrix();
    elevateBy(-block[BLOCK_MIN].h/2);
    matrixStack.pushMatrix();
      matrixStack.rotateY(90);
      move(0,-1.5);
      drawSpecularObject(objects[block[BLOCK_MIN].index], color);
      move(0,3);
      drawSpecularObject(objects[block[BLOCK_MIN].index], color);
    matrixStack.popMatrix();
  matrixStack.popMatrix();
    
  var offset = (block[DOOR].h/2)-(PAD_HEIGHT_DEF/2);
  matrixStack.pushMatrix();
    elevateBy(offset);
    drawSpecularObject(objects[block[PAD_DBL].index], color);
  matrixStack.popMatrix();
  
  matrixStack.pushMatrix();
    elevateBy(-offset);
    drawSpecularObject(objects[block[PAD_DBL].index], color);
  matrixStack.popMatrix();
  
  drawPegs(block[DOOR], color);
  move(0,1.01);
  
  matrixStack.pushMatrix();
    if(animating[ANIM_DOOR]) {
      if(doorOpening) {
        doorRotatedDeg += 1;
      } else {
        doorRotatedDeg -= 1;
      }
      if(doorRotatedDeg > 105 || doorRotatedDeg < 1) { // stop animation
        animating[ANIM_DOOR] = false;
        doorOpening = !doorOpening;
      }
    }
    matrixStack.translate((block[DOOR].w-0.25)/2,0,0);
    matrixStack.rotateY(doorRotatedDeg);
    matrixStack.translate(-(block[DOOR].w-0.25)/2,0,0);
    drawTexturedRectangle(block[DOOR].w-0.25,block[DOOR].h-0.5,TEX_DOOR, true);
  matrixStack.popMatrix();
  
  gl.useProgram(specShader.prog);
  matrixStack.popMatrix();
}

// draw window, with blocks and a texture as the door
function drawWindow(color) {
  matrixStack.pushMatrix();
  matrixStack.translate(0,block[WINDOW].h/2,0);
  
  matrixStack.pushMatrix();
    matrixStack.rotateY(90);
    move(0,-1.5);
    drawSpecularObject(objects[block[BLOCK_MIN].index], color);
    move(0,3);
    drawSpecularObject(objects[block[BLOCK_MIN].index], color);
  matrixStack.popMatrix();
    
  var offset = (block[WINDOW].h/2)-(PAD_HEIGHT_DEF/2);
  matrixStack.pushMatrix();
    elevateBy(offset);
    drawSpecularObject(objects[block[PAD_DBL].index], color);
  matrixStack.popMatrix();
  
  matrixStack.pushMatrix();
    elevateBy(-offset);
    drawSpecularObject(objects[block[PAD_DBL].index], color);
  matrixStack.popMatrix();
  
  drawPegs(block[WINDOW], color);
  move(0,1.01);
  
  matrixStack.pushMatrix();
    if(animating[ANIM_WINDOW]) {
      if(windowOpening) {
        windowRotatedDeg += 1;
      } else {
        windowRotatedDeg -= 1;
      }
      if(windowRotatedDeg > 105 || windowRotatedDeg < 1) { // stop animation
        animating[ANIM_WINDOW] = false;
        windowOpening = !windowOpening;
      }
    }
    matrixStack.translate((block[WINDOW].w-0.25)/2,0,0);
    matrixStack.rotateY(windowRotatedDeg);
    matrixStack.translate(-(block[WINDOW].w-0.25)/2,0,0);
    var useTex = (color === YELLOW) ? TEX_WINDOW2 : TEX_WINDOW;
    drawTexturedRectangle(block[WINDOW].w-0.25,block[WINDOW].h-0.5,useTex, true);
  matrixStack.popMatrix();
  
  gl.useProgram(specShader.prog);
  matrixStack.popMatrix();
}

function drawBlockCircle(color) {
  matrixStack.pushMatrix();
  matrixStack.translate(0,block[BLOCK_CIRCLE].h/2,0);
  matrixStack.rotateX(90);
  drawSpecularObject(objects[block[BLOCK_CIRCLE].index], color);
  matrixStack.popMatrix();
  matrixStack.pushMatrix();
  matrixStack.translate(0,block[BLOCK_CIRCLE].h/2,0);
  drawPegs(block[BLOCK_CIRCLE], color);
  matrixStack.popMatrix();
}

// draw half circle shaped block
function drawBlockHC(color) {
  matrixStack.pushMatrix();
    matrixStack.translate(0,block[BLOCK_HC].h/2,0);
    drawSpecularObject(objects[block[BLOCK_HC].index], color);
  matrixStack.popMatrix();
}

// build the arch type block
function drawBlockArch(color) {
  var arch = box(PEG*4,BLOCK_HEIGHT_DEF,PEG*2);
  matrixStack.pushMatrix();
    matrixStack.pushMatrix();
      matrixStack.pushMatrix();
        matrixStack.translate(-BLOCK_HEIGHT_DEF-0.5,BLOCK_HEIGHT_DEF-0.1,0);
        matrixStack.rotateZ(20);
        drawSpecularObject(arch, color);
      matrixStack.popMatrix();
      matrixStack.pushMatrix();
        matrixStack.translate(BLOCK_HEIGHT_DEF+0.5,BLOCK_HEIGHT_DEF-0.1,0);
        matrixStack.rotateZ(-20);
        drawSpecularObject(arch, color);
      matrixStack.popMatrix();
      move(-4,0);
      drawBlock(BLOCK_QTR, color);
      move(8,0);
      drawBlock(BLOCK_QTR, color);
    matrixStack.popMatrix();
    elevateBy(BLOCK_HEIGHT_DEF); // def is to disable reaction to explode function
    drawBlock(BLOCK_TRP, color);
  matrixStack.popMatrix();
}

// draw block described by blockNum with given color, will automatically add necessary pegs
function drawBlock(blockNum, color) {
  if(blockNum === BLOCK_E) {
    drawE(color);
    return;
  } else if(blockNum === DOOR) {
    drawDoor(color);
    return;
  } else if(blockNum === WINDOW) {
    drawWindow(color);
    return;
  } else if(blockNum === BLOCK_CIRCLE) {
    drawBlockCircle(color);
    return;
  } else if(blockNum === BLOCK_HC) {
    drawBlockHC(color);
    return;
  } else if(blockNum === BLOCK_ARCH) {
    drawBlockArch(color);
    return;
  } else if(blockNum === LADDER) {
    drawLadder(color);
    return;
  } else if(blockNum === FLOWER) {
    drawFlower(color);
    return;
  } else if(blockNum === DOG) {
    drawDog();
    return;
  } else if(blockNum === FENCE) {
    drawFence(color);
    return;
  }
  
  matrixStack.pushMatrix();
  matrixStack.translate(0,block[blockNum].h/2,0);
  drawPegs(block[blockNum], color);
  drawSpecularObject(objects[block[blockNum].index], color);
  matrixStack.popMatrix();
}

// animate the door upon user click
function toggleDoor() {
  setAnimating(!animating[ANIM_DOOR], ANIM_DOOR);
}
// animate the door upon user click
function toggleWindow() {
  setAnimating(!animating[ANIM_WINDOW], ANIM_WINDOW);
}
// animate the ladder upon user click
function toggleLadder() {
  setAnimating(!animating[ANIM_LADDER], ANIM_LADDER);
}
// fun way to view the tower!
function toggleExplode() {
  setAnimating(!animating[ANIM_EXPLODE], ANIM_EXPLODE);
}

// animate the separation of blocks, based on first line's rateOfChange (speed)
function handleExplode() {
  var speed = 0.02;
  if(animating[ANIM_EXPLODE]) {
    if(!explodedView) {
      PAD_HEIGHT += speed;
      BLOCK_HEIGHT += speed;
    } else {
      PAD_HEIGHT -= speed;
      BLOCK_HEIGHT -= speed;
    }
    if(PAD_HEIGHT > (PAD_HEIGHT_DEF*2) || PAD_HEIGHT < PAD_HEIGHT_DEF) { // stop animation
      if(PAD_HEIGHT < PAD_HEIGHT_DEF) { // make sure pad height is exact
        PAD_HEIGHT = PAD_HEIGHT_DEF;
        BLOCK_HEIGHT = BLOCK_HEIGHT_DEF;
      }
      animating[ANIM_EXPLODE] = false;
      explodedView = !explodedView;
    }
  }
}

function drawDog() {
  matrixStack.pushMatrix();
    matrixStack.translate(0,BLOCK_HEIGHT_DEF,0);
    matrixStack.rotateY(-25);
    drawTexturedRectangle(BLOCK_HEIGHT_DEF*4,BLOCK_HEIGHT_DEF*2,TEX_DOG,true);
  matrixStack.popMatrix();
  gl.useProgram(specShader.prog);
}

// manually draw a fence
function drawFence(color) {
  var scale = 1.2;
  var vertPipe = uvCylinder(3/8/4,BLOCK_HEIGHT_DEF);
  var horizPipe = uvCylinder(3/8/4,PEG*5);
  matrixStack.pushMatrix();
    matrixStack.pushMatrix();
      matrixStack.translate(0,5/16,0);
      matrixStack.rotateY(90);
      drawSpecularObject(horizPipe, color); // draw horizontal bars
      matrixStack.translate(0,BLOCK_HEIGHT_DEF-(5/16),0);
      drawSpecularObject(horizPipe, color); // draw horizontal bars
    matrixStack.popMatrix();
    matrixStack.translate(0,3/16/2,0); // half of peg height
    matrixStack.rotateX(90);
    matrixStack.pushMatrix();
      move(-2.5,0);
      matrixStack.pushMatrix();
        matrixStack.scale(scale,scale,scale);
        drawSpecularObject(objects[0], color); // use peg for bottom of fence
      matrixStack.popMatrix();
      matrixStack.pushMatrix();
        matrixStack.translate(0,0,-BLOCK_HEIGHT_DEF/2);
        drawSpecularObject(vertPipe, color); // draw outer vertical pipe
        matrixStack.translate(PEG,0,0);
        matrixStack.pushMatrix();
          for(var i = 0; i < 4; i++) { //draw all inner vertical pipes
            matrixStack.pushMatrix();
              matrixStack.scale(0.8,0.3,0.8); // inner pipes will be smaller
              matrixStack.translate(0,0,-1/16);
              drawSpecularObject(vertPipe, color);
            matrixStack.popMatrix();
            matrixStack.translate(PEG,0,0);
          }
          drawSpecularObject(vertPipe, color); // draw last vertical pipe
        matrixStack.popMatrix();
      matrixStack.popMatrix();
      move(5,0);
      matrixStack.pushMatrix();
        matrixStack.scale(scale,scale,scale);
        drawSpecularObject(objects[0], color);
      matrixStack.popMatrix();
    matrixStack.popMatrix();
    elevateBy(BLOCK_HEIGHT_DEF); // def is to disable reaction to explode function
    //drawBlock(BLOCK_TRP, color);
  matrixStack.popMatrix();
}

/* Draws a colored cube, along with a set of coordinate axes.
 * (Note that the use of the above drawPrimitive function is not an efficient
 * way to draw with WebGL.  Here, the geometry is so simple that it doesn't matter.)
 */
function draw() {
  gl.useProgram(mainShader.prog); // always come back to default shader
  
  gl.clearColor(0,0,0.2,1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  mat4.perspective(projection, Math.PI/8, 640/480, 4, 100);
  
  /* Set the value of modelview to represent the viewing transform. */
  //var modelview = rotator.getViewMatrix();
  matrixStack.setCurrentMatrix(rotator.getViewMatrix());
  matrixStack.translate(0,transY-15,viewZ);
  rotator.setRotationCenter([0,0,viewZ]);
  matrixStack.combineAndSend(mainShader.u_modelviewProj);
  
  /* Get the matrix for transforming normal vectors from the modelview matrix. */
  mat3.normalFromMat4(normalMatrix, matrixStack.getCurrentMatrix());
  gl.uniformMatrix3fv(mainShader.u_normalMatrix, false, normalMatrix);

  // handle exploded view
  if(animating[ANIM_EXPLODE]) {
    handleExplode();
  }
  
  // start drawing the tower!
  drawBlock(BASE, GREEN); // draw green pad at bottom
  elevateBy(PAD_HEIGHT);
  
  // draw first orange flower, and other block of this layer
  matrixStack.pushMatrix();
    drawBlock(PAD_FULL, GREEN);
    move(-3.5,3.5);
    drawBlock(FLOWER, ORANGE);
    move(3.5,-6.5);
    drawBlock(BLOCK_QTR, LIME);
    move(1,5);
    drawBlock(BLOCK_TRP, RED);
  matrixStack.popMatrix();
  matrixStack.pushMatrix();
    move(1,3.5);
    drawBlock(FENCE, YELLOW);
  matrixStack.popMatrix();
  elevateBy(PAD_HEIGHT);
  
  matrixStack.pushMatrix();
  move(-3,0);
  drawBlock(BLOCK_QTR, RED);
  move(6,0);
  drawBlock(BLOCK_QTR, CYAN);
  matrixStack.popMatrix();
  elevateBy(PAD_HEIGHT);
  
  // draw two bottom e's
  matrixStack.pushMatrix();
  move(0.5,1.5);
  drawBlock(BLOCK_E, RED);
  move(1,1);
  drawBlock(BLOCK_E, RED);
  matrixStack.popMatrix();
  elevateBy(PAD_HEIGHT);
  
  matrixStack.pushMatrix();
  drawBlock(PAD_TRP, GREEN);
  matrixStack.popMatrix();
  elevateBy(PAD_HEIGHT);
  
  matrixStack.pushMatrix();
  move(2,0);
    matrixStack.pushMatrix();
    drawBlock(BLOCK_QTR, RED);
    elevateBy(BLOCK_HEIGHT);
    drawBlock(BLOCK_QTR, RED);
    elevateBy(BLOCK_HEIGHT);
    drawBlock(BLOCK_QTR, RED);
    elevateBy(BLOCK_HEIGHT);
    drawBlock(BLOCK_QTR, CYAN);
    elevateBy(BLOCK_HEIGHT);
    drawBlock(BLOCK_QTR, CYAN);
    elevateBy(BLOCK_HEIGHT);
    drawBlock(BLOCK_QTR, RED);
    matrixStack.popMatrix();
  move(-4,0);
    matrixStack.pushMatrix();
    drawBlock(BLOCK_QTR, RED);
    elevateBy(BLOCK_HEIGHT);
    drawBlock(BLOCK_QTR, RED);
    elevateBy(BLOCK_HEIGHT);
      matrixStack.pushMatrix();
      matrixStack.rotateY(90);
      move(0,-0.5);
      drawBlock(BLOCK_MIN, CYAN);
      move(0,1);
      drawBlock(BLOCK_MIN, WHITE);
      matrixStack.popMatrix();
    elevateBy(BLOCK_HEIGHT*2);
    drawBlock(BLOCK_QTR, RED);
    elevateBy(BLOCK_HEIGHT);
    drawBlock(BLOCK_QTR, RED);
    matrixStack.popMatrix();
  matrixStack.popMatrix();
  elevateBy(BLOCK_HEIGHT);
  
  // draw and animate the door
  matrixStack.pushMatrix();
  move(1,2);
  drawBlock(DOOR, RED);
  matrixStack.popMatrix();
  elevateBy(BLOCK_HEIGHT*5);
  
  // draw green pad and window
  drawBlock(PAD_TRP, GREEN);
  matrixStack.pushMatrix();
  move(1,2);
  drawBlock(WINDOW, RED);
  elevateBy(BLOCK_HEIGHT*3);
  move(-1,0);
  drawBlock(BLOCK_QTR, LIME);
  move(2,0);
  drawBlock(BLOCK_QTR, RED);
  elevateBy(BLOCK_HEIGHT);
  drawBlock(BLOCK_QTR, RED);
  move(-2,0);
  drawBlock(BLOCK_QTR, BROWN);
  elevateBy(BLOCK_HEIGHT);
  move(1,0);
  drawBlock(PAD_DBL, RED);
  elevateBy(PAD_HEIGHT);
  drawBlock(PAD_DBL, WHITE);
  elevateBy(PAD_HEIGHT);
  drawBlock(PAD_DBL, RED);
  elevateBy(PAD_HEIGHT);
  drawBlock(WINDOW, YELLOW);
  elevateBy(BLOCK_HEIGHT*3);
  drawBlock(BLOCK_DBL, CYAN); // the cyan block with missing half cylinder
  elevateBy(BLOCK_HEIGHT);
  drawBlock(BLOCK_DBL, CYAN); // the cyan block with missing half cylinder
  elevateBy(BLOCK_HEIGHT);
  drawBlock(BLOCK_DBL, RED); // change this into BLOCK_HC
  matrixStack.popMatrix();
  elevateBy(PAD_HEIGHT);
  
  // level from green pad
  matrixStack.pushMatrix();
    move(-2,0);
    matrixStack.pushMatrix();
      drawBlock(BLOCK_QTR, YELLOW);
      elevateBy(BLOCK_HEIGHT);
      drawBlock(BLOCK_QTR, CYAN);
      elevateBy(BLOCK_HEIGHT);
      drawBlock(BLOCK_QTR, RED);
      elevateBy(BLOCK_HEIGHT);
      drawBlock(BLOCK_QTR, CYAN);
      elevateBy(BLOCK_HEIGHT);
      drawBlock(BLOCK_QTR, BROWN);
      elevateBy(BLOCK_HEIGHT);
      drawBlock(BLOCK_QTR, RED);
      elevateBy(BLOCK_HEIGHT);
      drawBlock(BLOCK_QTR, BROWN);
      elevateBy(BLOCK_HEIGHT);
      drawBlock(BLOCK_QTR, RED);
    matrixStack.popMatrix();
    move(3,0);
    drawBlock(BLOCK_DBL, RED);
    elevateBy(BLOCK_HEIGHT);
    drawBlock(BLOCK_DBL, RED);
    elevateBy(BLOCK_HEIGHT);
    drawBlock(BLOCK_DBL, YELLOW);
    elevateBy(BLOCK_HEIGHT);
    move(-1,0);
    drawBlock(BLOCK_QTR, RED);
    move(4,0);
    drawBlock(PAD_TRP, WHITE);
    elevateBy(PAD_HEIGHT);
    drawBlock(PAD_TRP, GREEN);
    elevateBy(PAD_HEIGHT);
    move(-2,0);
    matrixStack.pushMatrix();
      drawBlock(PAD_TRP, WHITE);
      elevateBy(PAD_HEIGHT);
      move(-1,0);
      drawBlock(PAD_DBL, RED);
    matrixStack.popMatrix();
    move(4,0);
    drawBlock(BLOCK_QTR, CYAN);
    elevateBy(BLOCK_HEIGHT);
    drawBlock(BLOCK_QTR, BROWN);
    elevateBy(BLOCK_HEIGHT);
    drawBlock(BLOCK_QTR, RED);
    elevateBy(BLOCK_HEIGHT);
    drawBlock(BLOCK_QTR, YELLOW);
    move(-4,0);
    drawBlock(BLOCK_QTR, RED);
    elevateBy(BLOCK_HEIGHT);
    matrixStack.pushMatrix(); // start extra wide section
      move(3,0);
      drawBlock(PAD_TRP, WHITE);
      move(-6,0);
      drawBlock(PAD_TRP, GREEN);
      elevateBy(PAD_HEIGHT);
      move(-3,0);
      drawBlock(BLOCK_TRP, RED);
      move(6,0);
      drawBlock(BLOCK_TRP, RED);
      move(6,0);
      drawBlock(PAD_TRP, WHITE);
      elevateBy(PAD_HEIGHT);
      move(1,0);
      drawBlock(PAD_DBL, LIME);
      move(-3,0);
      matrixStack.pushMatrix(); // for first red pad sticking out from side
        matrixStack.rotateY(90);
        move(1,0);
        drawBlock(PAD_DBL, RED);
      matrixStack.popMatrix();
      elevateBy(PAD_HEIGHT);
      drawBlock(BLOCK_DBL, YELLOW);
      matrixStack.pushMatrix();
        move(-4,0);
        matrixStack.pushMatrix();
          drawBlock(BLOCK_QTR, RED);
          elevateBy(BLOCK_HEIGHT);
          drawBlock(BLOCK_QTR, CYAN);
          elevateBy(BLOCK_HEIGHT);
          drawBlock(BLOCK_QTR, BROWN);
        matrixStack.popMatrix();
        move(-3,0);
        drawBlock(PAD_DBL, WHITE);
        move(-5,0);
        drawBlock(BLOCK_QTR, BROWN);
        elevateBy(BLOCK_HEIGHT);
        drawBlock(BLOCK_QTR, RED);
        elevateBy(BLOCK_HEIGHT);
        drawBlock(BLOCK_QTR, CYAN);
        elevateBy(BLOCK_HEIGHT);
        drawBlock(BLOCK_QTR, RED);
        elevateBy(BLOCK_HEIGHT);
        move(4,0);
        drawBlock(BLOCK_ARCH, RED); // left side arch
        elevateBy(BLOCK_HEIGHT*2);
        drawBlock(BLOCK_QTR, BLUE); // draw blue 'FOOT'
        elevateBy(BLOCK_HEIGHT);
        drawBlock(BLOCK_QTR, RED);
        elevateBy(BLOCK_HEIGHT);
        drawBlock(BLOCK_QTR, RED);
        elevateBy(BLOCK_HEIGHT);
        drawBlock(BLOCK_QTR, CYAN);
        elevateBy(BLOCK_HEIGHT);
        drawBlock(BLOCK_QTR, MAROON);
        elevateBy(BLOCK_HEIGHT);
        drawBlock(BLOCK_QTR, ORANGE);
        elevateBy(BLOCK_HEIGHT);
        matrixStack.pushMatrix();
          move(0,-0.5);
          drawBlock(BLOCK_MIN, CYAN);
          move(0,1);
          drawBlock(BLOCK_MIN, WHITE);
        matrixStack.popMatrix();
        elevateBy(BLOCK_HEIGHT*2);
        drawBlock(BLOCK_QTR, RED);
        elevateBy(BLOCK_HEIGHT);
        move(1,0);
        drawBlock(BLOCK_DBL, RED);
        move(-1,0);
        elevateBy(BLOCK_HEIGHT);
        drawBlock(BLOCK_QTR, RED);
        elevateBy(BLOCK_HEIGHT);
        drawBlock(BLOCK_QTR, CYAN);
        elevateBy(BLOCK_HEIGHT);
        matrixStack.pushMatrix();
          matrixStack.rotateY(90);
          move(0,-0.5);
          drawBlock(BLOCK_MIN, BLUE);
          move(0,1);
          drawBlock(BLOCK_MIN, BLUE);
        matrixStack.popMatrix();
        elevateBy(BLOCK_HEIGHT*2);
        drawBlock(BLOCK_QTR, BROWN);
        elevateBy(BLOCK_HEIGHT);
        drawBlock(BLOCK_DBL, GRAY);
      matrixStack.popMatrix();
      move(4,0);
      drawBlock(BLOCK_QTR, YELLOW);
      elevateBy(BLOCK_HEIGHT);
      drawBlock(BLOCK_QTR, YELLOW);
      elevateBy(BLOCK_HEIGHT);
      drawBlock(BLOCK_QTR, RED);
      elevateBy(BLOCK_HEIGHT);
      move(-4,0);
      drawBlock(BLOCK_ARCH, RED); // right side arch
      elevateBy(BLOCK_HEIGHT*2);
      drawBlock(BLOCK_TRP, RED);
      move(-4,0);
      drawBlock(BLOCK_QTR, RED);
      matrixStack.pushMatrix();
        elevateBy(BLOCK_HEIGHT);
        matrixStack.rotateY(90);
        matrixStack.pushMatrix();
          drawBlock(PAD_FULL, WHITE); // half of top pad
          move(0,-2);
          drawBlock(PAD_FULL, WHITE); // other half of top pad
          matrixStack.pushMatrix(); // draw two fences surrounding dog
            elevateBy(PAD_HEIGHT);
            move(0,-0.5);
            drawBlock(FENCE, YELLOW);
            move(0,3);
            drawBlock(FENCE, YELLOW);
          matrixStack.popMatrix();
        matrixStack.popMatrix();
        move(0,-1);
        elevateBy(PAD_HEIGHT);
        drawBlock(BLOCK_QTR, BLUE);
        matrixStack.pushMatrix();
          move(-4,0);
          drawBlock(PAD_DBL, RED);
          elevateBy(PAD_HEIGHT);
          move(-1,0);
          matrixStack.pushMatrix();
            move(-0.5,0);
            matrixStack.rotateY(-90);
            drawBlock(BLOCK_MIN, CYAN);
          matrixStack.popMatrix();
          move(2,0);
          drawBlock(BLOCK_CIRCLE, RED);
          elevateBy(BLOCK_HEIGHT_DEF);
          drawBlock(BLOCK_CIRCLE, RED);
        matrixStack.popMatrix();
        elevateBy(BLOCK_HEIGHT);
        drawBlock(BLOCK_QTR, ORANGE);
        elevateBy(BLOCK_HEIGHT);
        move(-0.5,0);
        drawBlock(DOG, WHITE); // draw dog
      matrixStack.popMatrix();
      move(3,0);
      elevateBy(BLOCK_HEIGHT);
      drawBlock(BLOCK_DBL, GREEN);
      elevateBy(BLOCK_HEIGHT);
      drawBlock(BLOCK_QTR, RED);
      elevateBy(BLOCK_HEIGHT);
      drawBlock(BLOCK_QTR, RED);
      elevateBy(BLOCK_HEIGHT);
      drawBlock(BLOCK_QTR, GREEN);
      elevateBy(BLOCK_HEIGHT);
      drawBlock(BLOCK_QTR, CYAN);
      elevateBy(BLOCK_HEIGHT);
      drawBlock(BLOCK_QTR, CYAN);
      elevateBy(BLOCK_HEIGHT);
      matrixStack.pushMatrix();
        matrixStack.rotateY(90);
        move(-0.5,0);
        drawBlock(BLOCK_DBL, RED); // draw red 'FOOT'
      matrixStack.popMatrix();
      elevateBy(BLOCK_HEIGHT);
      move(0,1);
      drawBlock(BLOCK_QTR, GREEN);
      elevateBy(BLOCK_HEIGHT);
      drawBlock(LADDER, BLACK);
    matrixStack.popMatrix();
  matrixStack.popMatrix();
  
  //enable user to toggle axes
  if(document.getElementById("axes").checked) {
    drawAxes();
  }
}

/*
 *  Loads a texture image asynchronously.  The first paramter is the url
 *  from which the image is to be loaded.  The second parameter is the
 *  texture object into which the image is to be loaded.  When the image
 *  has finished loading, the draw() function will be called to draw the
 *  triangle with the texture.  (Also, if an error occurs during loading,
 *  an error message is displayed on the page, and draw() is called to
 *  draw the triangle without the texture.)
 */
function loadTexture( url, textureUnit, textureObj ) {
  var img = new Image();  //  A DOM image element to represent the image.
  img.onload = function() { 
    // This function will be called after the image loads successfully.
    // We have to bind the texture object to the TEXTURE_2D target before
    // loading the image into the texture object. 
    gl.activeTexture(textureUnit);
    gl.bindTexture(gl.TEXTURE_2D, textureObj);
    
    try {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
    } catch (e) {
      document.getElementById("headline").innerHTML =
              "Can't access texture.  Note that some browsers can't use  a texture from a local file.";
      return;
    }
    
    gl.generateMipmap(gl.TEXTURE_2D);  // Create mipmaps; you must either
                          // do this or change the minification filter.
    draw();  // Draw the canvas, with the texture.  
  };
  img.onerror = function(e,f) { 
    // This function will be called if an error occurs while loading.
    document.getElementById("headline").innerHTML =
                    "<p>Sorry, texture image could not be loaded.</p>";
    draw();  // Draw without the texture; triangle will be black.
  };
  img.src = url;  // Start loading of the image.
                  // This must be done after setting onload and onerror.
}

/* Called when the user changes the selection in the model-selection pop-up.
 * The data for the model are copied into the appropriate buffers, and the
 * scene is redrawn.
 */
function installModel(modelData) {
  gl.bindBuffer(gl.ARRAY_BUFFER, specShader.a_coords_buffer);
  gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexPositions, gl.STATIC_DRAW);
  gl.vertexAttribPointer(specShader.a_coords_loc, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(specShader.a_coords_loc);

  gl.bindBuffer(gl.ARRAY_BUFFER, specShader.a_normal_buffer);
  gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexNormals, gl.STATIC_DRAW);
  gl.vertexAttribPointer(specShader.a_normal_loc, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(specShader.a_normal_loc);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,specShader.index_buffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, modelData.indices, gl.STATIC_DRAW);
}

/* Initialize the WebGL context.  Called from init() */
function initGL() {
  mainShader = {};
  mainShader.prog = createProgram(gl,"vshaderBASIC","fshaderBASIC");
  gl.useProgram(mainShader.prog);
  mainShader.a_coords_loc =  gl.getAttribLocation(mainShader.prog, "a_coords");
  mainShader.u_modelviewProj = gl.getUniformLocation(mainShader.prog, "modelviewProjection");
  mainShader.u_color =  gl.getUniformLocation(mainShader.prog, "color");
  mainShader.u_lit =  gl.getUniformLocation(mainShader.prog, "lit");
  mainShader.u_normal =  gl.getUniformLocation(mainShader.prog, "normal");
  mainShader.u_normalMatrix =  gl.getUniformLocation(mainShader.prog, "normalMatrix");
  mainShader.a_coords_buffer = gl.createBuffer();
  
  texShader = {};
  texShader.prog = createProgram(gl,"vshaderTEX","fshaderTEX");
  gl.useProgram(texShader.prog);
  texShader.u_modelviewProj = gl.getUniformLocation(texShader.prog, "modelviewProjection");
  texShader.a_coords_loc =  gl.getAttribLocation(texShader.prog, "a_coords");
  texShader.a_texCoords_loc = gl.getAttribLocation(texShader.prog, "a_texCoords");
  texShader.u_texture_loc = gl.getUniformLocation(texShader.prog, "u_texture");
  texShader.u_lit =  gl.getUniformLocation(texShader.prog, "lit");
  texShader.u_normal =  gl.getUniformLocation(texShader.prog, "normal");
  texShader.u_normalMatrix =  gl.getUniformLocation(texShader.prog, "normalMatrix");
  texShader.a_coords_buffer = gl.createBuffer();
  texShader.a_texCoords_buffer = gl.createBuffer();
  gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, 1 );
  
  // load all the textures and create their respective objects
  var TOTAL_TEXTURES = 4;
  var textures = [];
  textures[0] = "textures/door.png";
  textures[1] = gl.TEXTURE0;
  textures[2] = "textures/window.png";
  textures[3] = gl.TEXTURE1;
  textures[4] = "textures/window2.png";
  textures[5] = gl.TEXTURE2;
  textures[6] = "textures/dog.png";
  textures[7] = gl.TEXTURE3;
  
  for(var i = 0; i < TOTAL_TEXTURES; i++) {
    textureObject[i] = gl.createTexture();
    loadTexture( textures[i*2], textures[i*2+1], textureObject[i] );  // load the texture image
  }
  
  specShader = {};
  specShader.prog = createProgram(gl,"vshaderSPEC","fshaderSPEC");
  gl.useProgram(specShader.prog);
  specShader.u_lit =  gl.getUniformLocation(specShader.prog, "lit");
  specShader.a_coords_loc = gl.getAttribLocation(specShader.prog, "a_coords");
  specShader.a_normal_loc = gl.getAttribLocation(specShader.prog, "a_normal");
  specShader.u_modelview_loc = gl.getUniformLocation(specShader.prog, "modelview");
  specShader.u_projection_loc = gl.getUniformLocation(specShader.prog, "projection");
  specShader.u_normalMatrix_loc = gl.getUniformLocation(specShader.prog, "normalMatrix");
  specShader.u_lightPosition_loc = gl.getUniformLocation(specShader.prog, "lightPosition");
  specShader.u_diffuseColor_loc = gl.getUniformLocation(specShader.prog, "diffuseColor");
  specShader.u_specularColor_loc = gl.getUniformLocation(specShader.prog, "specularColor");
  specShader.u_specularExponent_loc = gl.getUniformLocation(specShader.prog, "specularExponent");
  specShader.a_coords_buffer = gl.createBuffer();
  specShader.a_normal_buffer = gl.createBuffer();
  specShader.index_buffer = gl.createBuffer();
  
  // set default lighting
  gl.uniform3f(specShader.u_specularColor_loc, 0.5, 0.5, 0.5);
  gl.uniform4f(specShader.u_diffuseColor_loc, 1, 1, 1, 1);
  gl.uniform1f(specShader.u_specularExponent_loc, 10);
  gl.uniform4fv(specShader.u_lightPosition_loc, lightPositions[0]);
  
  gl.enable(gl.DEPTH_TEST);
}

/* Creates a program for use in the WebGL context gl, and returns the
 * identifier for that program.  If an error occurs while compiling or
 * linking the program, an exception of type String is thrown.  The error
 * string contains the compilation or linking error.  If no error occurs,
 * the program identifier is the return value of the function.
 *    The second and third parameters are the id attributes for <script>
 * elementst that contain the source code for the vertex and fragment
 * shaders.
 */
function createProgram(gl, vertexShaderID, fragmentShaderID) {
  function getTextContent( elementID ) {
          // This nested function retrieves the text content of an
          // element on the web page.  It is used here to get the shader
          // source code from the script elements that contain it.
    var element = document.getElementById(elementID);
    var node = element.firstChild;
    var str = "";
    while (node) {
      if (node.nodeType === 3) { // this is a text node
        str += node.textContent;
      }
      node = node.nextSibling;
    }
    return str;
  }
  try {
    var vertexShaderSource = getTextContent( vertexShaderID );
    var fragmentShaderSource = getTextContent( fragmentShaderID );
  } catch (e) {
    throw "Error: Could not get shader source code from script elements.";
  }
  var vsh = gl.createShader( gl.VERTEX_SHADER );
  gl.shaderSource(vsh,vertexShaderSource);
  gl.compileShader(vsh);
  if ( ! gl.getShaderParameter(vsh, gl.COMPILE_STATUS) ) {
    throw "Error in vertex shader:  " + gl.getShaderInfoLog(vsh);
  }
  var fsh = gl.createShader( gl.FRAGMENT_SHADER );
  gl.shaderSource(fsh, fragmentShaderSource);
  gl.compileShader(fsh);
  if ( ! gl.getShaderParameter(fsh, gl.COMPILE_STATUS) ) {
    throw "Error in fragment shader:  " + gl.getShaderInfoLog(fsh);
  }
  var prog = gl.createProgram();
  gl.attachShader(prog,vsh);
  gl.attachShader(prog, fsh);
  gl.linkProgram(prog);
  if ( ! gl.getProgramParameter( prog, gl.LINK_STATUS) ) {
    throw "Link error in program:  " + gl.getProgramInfoLog(prog);
  }
  return prog;
}

//--------------------------------- animation framework ------------------------------
// indices for different animations
var ANIM_DOOR = 0;
var ANIM_WINDOW = 1;
var ANIM_LADDER = 2;
var ANIM_EXPLODE = 3;

var animating = [];
animating[ANIM_DOOR] = false;
animating[ANIM_WINDOW] = false;
animating[ANIM_LADDER] = false;
animating[ANIM_EXPLODE] = false;


function frame() {
  if (animating[ANIM_DOOR] || animating[ANIM_EXPLODE] || animating[ANIM_WINDOW]
          || animating[ANIM_LADDER]) {
    frameNumber += 1;
    draw();
    requestAnimationFrame(frame);
  }
}

function setAnimating(run, objectNum) {
  if (run !== animating[objectNum]) {
    animating[objectNum] = run;
    if (animating[objectNum]) {
      requestAnimationFrame(frame);
    }
  }
}

/**
 *  An event listener for the keydown event.  It is installed by the init() function.
 *  The arrow keys, PageUp, and PageDown will rotate the cube by modifying the
 *  modeling transformation.  Home and Return key resets the modeling transform
 *  to the identity.
 *  @param evt
 */
function doKey(evt) {
    var rotationChanged = true;
    switch (evt.keyCode) {
      case 38: transY -= 1; break;        // up arrow
      case 40: transY += 1; break;        // down arrow
      case 36: transY = 0; break;  // home key
      default: rotationChanged = false;
    }
    if (rotationChanged) {
      evt.preventDefault();
      draw();
    }
}

/**
 * initialization function that will be called when the page has loaded
 */
function init() {
  try {
    var canvas = document.getElementById("webglcanvas");
    gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
    if ( ! gl ) {
      throw "Browser does not support WebGL";
    }
  } catch (e) {
    document.getElementById("canvas-holder").innerHTML =
            "<p>Sorry, could not get a WebGL graphics context.</p>";
    return;
  }
  try {
    initGL();  // initialize the WebGL graphics context
  } catch (e) {
    document.getElementById("canvas-holder").innerHTML =
            "<p>Sorry, could not initialize the WebGL graphics context:" + e + "</p>";
    return;
  }
  document.getElementById("gLight").checked = true;
  document.getElementById("gLight").onchange = function() {
    gl.useProgram(mainShader.prog);
    gl.uniform1i(mainShader.u_lit, (document.getElementById("gLight").checked) ? 1 : 0);
    gl.useProgram(specShader.prog);
    gl.uniform1i(specShader.u_lit, (document.getElementById("gLight").checked) ? 1 : 0);
    draw();
  };
  document.addEventListener("keydown", doKey, false);
  document.getElementById("explode").onclick = toggleExplode;
  document.getElementById("window").onclick = toggleWindow;
  document.getElementById("ladder").onclick = toggleLadder;
  document.getElementById("door").onclick = toggleDoor;
  document.getElementById("scroll").checked = true;
  document.getElementById("scroll").onchange = toggleScroll;
  document.getElementById("axes").checked = false;
  document.getElementById("axes").onchange = draw;
  document.getElementById("lightPos").value = "0";
  document.getElementById("lightPos").onchange = function() {
    gl.useProgram(specShader.prog);
    gl.uniform4fv(specShader.u_lightPosition_loc, lightPositions[Number(this.value)]);
    draw();
  };
  gl.useProgram(mainShader.prog);
  gl.uniform1i(mainShader.u_lit, 1); // turn on global light in main shader
  gl.useProgram(specShader.prog);
  gl.uniform1i(specShader.u_lit, 1); // turn on global light in spec shader
  toggleScroll(); // enable scrolling by default
  rotator = new TrackballRotator(canvas, draw, 10);
  draw();
}

</script>
</head>
<body onload="init()">

<h2>Jesse Young Final Project - LEGO Tower</h2>

<p id=message>Use mouse drags to rotate the tower.<br>
Use mouse scroll to navigate the z-axis.<br>
Use up/down arrows to navigate the y-axis.</p>

<p>
  <label><input type="checkbox" name="lightingEnabled" id="gLight">Global Lighting</label>
  <label><input type="checkbox" name="scrollingEnabled" id="scroll">Mouse Scrolling</label>
  <label><input type="checkbox" name="axesEnabled" id="axes">Draw Axes</label>
  <label>Light Position:<select id="lightPos">
    <option value="0">[0,0,0,1] (Viewpoint light)</option>
    <option value="1">[0,0,1,0] (Directional, into screen)</option>
    <option value="2">[0,1,0,0] (Directional, from above)</option>
    <option value="3">[0,0,-5,1] (On z-axis, close to object)</option>
    <option value="4">[2,3,5,0] (Directional from upper right)</option>
  </select></label>
  <br/><label><input type="button" name="doorAnimEnabled" id="door" value="Open/Close Door"></label>
  <label><input type="button" name="windowAnimEnabled" id="window" value="Open/Close Windows"></label>
  <label><input type="button" name="ladderAnimEnabled" id="ladder" value="Open/Close Ladder"></label>
  <label><input type="button" name="explodeAnimEnabled" id="explode" value="Toggle Exploded View"></label>
</p>

<noscript><hr><h3>This page requires Javascript and a web browser that supports WebGL</h3><hr></noscript>

<div id="canvas-holder">
  <canvas width=640 height=480 id="webglcanvas" style="background-color:red"></canvas>
</div>

</body>
</html>

